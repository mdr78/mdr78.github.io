#+STARTUP: showall indentX
#+STARTUP: hidestars
#+OPTIONS: H:2 num:nil tags:nil toc:nil timestamps:nil ^:nil |:nil
#+BEGIN_EXPORT html
---
layout: default
title: Why is ABI Stability important?
---
#+END_EXPORT

* Why is ABI stability important?

Most open-source software projects follow distinct life cycle patterns as they
evolve from the genesis of a idea, all the way through to a mature stable
well-defined project. You can see this evolution reflected in all aspects of the
project. Upstreaming rules for instance, are usually permissive in the early
days and then become gradually more conservative and risk adverse over time.
Similarly, you expect lots of bugs in the early days, then things becomes more
tested and stable over time, and so on.

This life-cycle is also evident in a project's management of it's application
binary interface, usually shortened to ABI. Before continuing, two things should
be pointed out;

1. If you are bit fuzzy on what I mean by ABI, also know as "binary
   compatibility", you should read through the [[https://en.wikipedia.org/wiki/Application_binary_interface][wikipedia entry]] on it.
2. We have made quite a bit of use of the dataset's and tools from the [[https://abi-laboratory.pro][ABI
   Laboratory project]]. It's worth following the links to that project below to
   review the data-sets, we annotated those links with a †.

In the early days of a project, ABI changes are rarely given any consideration
as you are usually /way/ too busy trying to change the world! Then time goes on
and the project becomes popular. The more users join the project, and become
dependent on it, the more time you spend making sure that you don't break their
software.

At the extreme end of this cycle are very mature projects like the Linux
Kernel. Linus Torvalds explains Linux's commitment to maintaining a stable ABI
in his [[https://yarchive.net/comp/linux/gcc_vs_kernel_stability.html][own words]].

#+BEGIN_QUOTE
We care about user-space interfaces to an insane degree. We go to extreme
lengths to maintain even badly designed or unintentional interfaces. Breaking
user programs simply isn't acceptable. -- Linus Torvalds, 2005
#+END_QUOTE

There are a few distinct patterns of ABI management, between fledgling and very
mature project's like Linux.

** Patterns of ABI management

In some software libraries, an evolutionary pattern is very clear, that is they
follow the common pattern of an unstable ABI in their early day's and then
after some period of settling they declare a *1.0 release* and their ABI is more
or less set in stone from that point on-wards. The [[https://abi-laboratory.pro/index.php?view=timeline&l=gstreamer][GStreamer (†)]] project is good
example of this form evolution.

#+PLOT: set:"xtics rotate" timefmt "%d/%m/%Y"
#+PLOT: title:"GStreamer Backward Compatibility"
#+PLOT: set:"yrange [0:110]" set:"ylabel '% Compatibility'" set:"key off"
#+PLOT: ind:2 deps:(3) type:2d with:linespoints with:labels 
#+PLOT: file:"~/blog/mdr78.github.io/Org/gstreamer.png"
|   Version | Date       | Backward Compatibility |
|   0.10.35 | 15/06/2011 |                    N/A |
| 0.10.35.2 | 10/12/2011 |                   100% |
| 0.10.35.3 | 05/02/2012 |                 99.29% |
|   0.10.36 | 21/02/2012 |                   100% |
|    0.11.0 | 02/08/2011 |                 50.83% |
|    0.11.1 | 29/09/2011 |                 97.26% |
|    0.11.2 | 17/02/2012 |                 58.44% |
|    0.11.3 | 22/03/2012 |                 82.81% |
|   0.11.90 | 12/04/2012 |                 98.77% |
|   0.11.91 | 13/05/2012 |                 94.73% |
|   0.11.92 | 07/06/2012 |                 97.51% |
|   0.11.93 | 08/08/2012 |                 78.19% |
|   0.11.94 | 14/09/2012 |                 99.03% |
|   0.11.99 | 17/09/2012 |                   100% |
|     1.0.0 | 24/09/2012 |                   100% |
|     1.1.1 | 05/06/2013 |                   100% |
|    1.10.0 | 01/11/2016 |                   100% |
|    1.11.1 | 12/01/2017 |                   100% |
|    1.12.0 | 04/05/2017 |                   100% |
|    1.13.1 | 15/02/2018 |                   100% |
|    1.14.0 | 19/03/2018 |                   100% |
|    1.15.1 | 17/01/2019 |                   100% |
|    1.16.0 | 19/04/2019 |                   100% |
|     1.2.0 | 24/09/2013 |                   100% |
|     1.3.1 | 03/05/2014 |                   100% |
|     1.4.0 | 19/07/2014 |                   100% |
|     1.5.1 | 07/06/2015 |                 99.91% |
|     1.6.0 | 25/09/2015 |                   100% |
|     1.7.1 | 24/12/2015 |                   100% |
|     1.8.0 | 24/03/2016 |                   100% |
|     1.9.1 | 06/07/2016 |                   100% |


[[file:~/blog/mdr78.github.io/Org/gstreamer.png]]
 
Some software projects, particularly programming languages and operating
systems, by virtue of being governed either by a strict set of standards and/or
the requirement to offer very strong guarantees about backward compatibility,
change very rarely. That is, they have a well-defined ABI from the start and it
very rarely changes thereafter, with is no period of stablization as such.
[[https://abi-laboratory.pro/index.php?view=timeline&l=libcxxabi][LibC++ (†)]] and [[https://abi-laboratory.pro/index.php?view=timeline&l=glibc][GlibC (†)]] are good examples of these sorts of projects.

#+PLOT: set:"xtics rotate" timefmt "%d/%m/%Y"
#+PLOT: title:"glibc Backward Compatibility"
#+PLOT: set:"yrange [0:110]" set:"ylabel '% Compatibility'" set:"key off"
#+PLOT: ind:2 deps:(3) type:2d with:linespoints with:labels 
#+PLOT: file:"~/blog/mdr78.github.io/Org/glibc.png"
| Version | Date       | Backward Compat |
|    2.13 | 18/01/2011 |             N/A |
|  2.14.1 | 07/10/2011 |            100% |
|    2.14 | 31/05/2011 |            100% |
|    2.15 | 19/03/2012 |          99.92% |
|  2.16.0 | 30/06/2012 |            100% |
|    2.17 | 25/12/2012 |          99.87% |
|    2.18 | 11/08/2013 |          99.66% |
|    2.19 | 07/02/2014 |            100% |
|     2.2 | 07/09/2014 |            100% |
|    2.21 | 06/02/2015 |          95.58% |
|    2.22 | 05/08/2015 |            100% |
|    2.23 | 18/02/2016 |          99.96% |
|    2.24 | 02/08/2016 |          99.76% |
|    2.25 | 05/02/2017 |          99.70% |
|    2.26 | 02/08/2017 |          99.54% |
|    2.27 | 01/02/2018 |          98.49% |
|    2.28 | 01/08/2018 |          99.92% |
|    2.29 | 31/01/2019 |          99.96% |
|     2.3 | 01/08/2019 |          94.30% |

[[file:~/blog/mdr78.github.io/Org/glibc.png]]

Other software projects will support a stable ABI version for some period of
time, usually months or more often years, with planned periodic ABI breakages to
introduce new features or to facilitate re-factoring. These breakage's are often
timed to coordinate with the lifecycle of consuming software such as operating
system distributions (Debian etc) or higher level applications. [[https://abi-laboratory.pro/index.php?view=timeline&l=libav][LibAV (†)]] and
[[https://abi-laboratory.pro/index.php?view=timeline&l=ffmpeg][ffmpeg (†)]] are clear examples of this kind of project.

#+PLOT: set:"xtics rotate" timefmt "%d/%m/%Y"
#+PLOT: title:"libav Backward Compatibility"
#+PLOT: set:"yrange [0:110]" set:"ylabel '% Compatibility'" set:"key off"
#+PLOT: ind:2 deps:(3) type:2d with:linespoints with:labels 
#+PLOT: file:"~/blog/mdr78.github.io/Org/libav.png"
| Version | Date       | Backward Compat |
|      10 | 23/03/2014 |           9.03% |
|    10.1 | 10/05/2014 |            100% |
|    10.2 | 27/06/2014 |            100% |
|    10.3 | 04/08/2014 |            100% |
|    10.4 | 17/08/2014 |            100% |
|    10.5 | 11/09/2014 |            100% |
|    10.6 | 09/03/2015 |            100% |
|    10.7 | 31/05/2015 |            100% |
|      11 | 13/09/2014 |              0% |
|    11.1 | 02/07/2017 |            100% |
|    11.1 | 02/12/2014 |            100% |
|   11.11 | 15/10/2017 |            100% |
|   11.12 | 04/02/2018 |            100% |
|    11.2 | 14/01/2015 |            100% |
|    11.3 | 09/03/2015 |            100% |
|    11.4 | 31/05/2015 |            100% |
|    11.5 | 24/02/2016 |            100% |
|    11.6 | 27/02/2016 |            100% |
|    11.7 | 25/05/2016 |            100% |
|    11.8 | 06/09/2016 |            100% |
|    11.9 | 10/04/2017 |            100% |
|      12 | 17/10/2016 |              0% |
|    12.1 | 14/05/2017 |            100% |
|    12.2 | 30/09/2017 |            100% |
|    12.3 | 13/02/2018 |            100% |

[[file:~/blog/mdr78.github.io/Org/libav.png]]

Finally, some software project's by virtue of a design philosophy or simply
because they are that bit earlier in their lifecycle, choose to offer fewer
guarantees of ABI compatibility. [[https://abi-laboratory.pro/index.php?view=timeline&l=dpdk][DPDK]] and [[https://abi-laboratory.pro/index.php?view=timeline&l=Boost][Boost]] projects are
both good examples of this kind of project.

#+PLOT: set:"xtics rotate" timefmt "%d/%m/%Y"
#+PLOT: title:"DPDK Backward Compatibility"
#+PLOT: set:"yrange [0:110]" set:"ylabel '% Compatibility'" set:"key off"
#+PLOT: ind:1 deps:(3) type:2d with:linespoints with:labels 
#+PLOT: file:"~/blog/mdr78.github.io/Org/dpdk.png"
 | Version | Date       | Backward Compatibility |
 |   16.04 | 12/04/2016 |                    N/A |
 |   16.07 | 28/07/2016 |                 82.15% |
 |   16.11 | 13/11/2016 |                 91.53% |
 |   17.02 | 15/02/2017 |                 98.04% |
 |   17.05 | 11/05/2017 |                 88.56% |
 |   17.08 | 08/08/2017 |                 93.25% |
 |   17.11 | 15/11/2017 |                 74.35% |
 |   18.02 | 14/02/2018 |                 97.86% |
 |   18.05 | 30/05/2018 |                 84.94% |
 |   18.08 | 10/08/2018 |                 95.10% |
 |   18.11 | 27/11/2018 |                 91.49% |
 |   19.02 | 01/02/2019 |                 94.58% |
 |   19.05 | 14/05/2019 |                 95.55% |
 |   19.08 | 11/08/2019 |                 97.79% |

[[file:~/blog/mdr78.github.io/Org/dpdk.png]]

** Why are ABI Breakages considered bad?

Modern software ecosystems are built on a hard commitment that binary interfaces
will be carefully managed. When this commitment does not hold things fall apart
rapidly, with applications failing to start or randomly crashing.

Imagine a world in which there was no guarantee that applications installed from
an 'app' store or repository would just work, imagine how frustrating that might
be for users? Today this all just works and we take for granted that behind the
scenes, engineers are working hard to ensure that updates don't break ABIs and
therefore do not break applications. However many will remember a [[https://en.wikipedia.org/wiki/DLL_Hell][time when]] such
guarantees either didn't exist or were hard to enforce.

And the consequences? Naturally defensive behaviours will follow, developers
will start to statically link with their dependencies and become slow about
picking up the latest version of those dependencies as being too risky. In the
worst case, some developers might start looking for another ecosystem that
doesn't break their code and their application quite so much.\\

And this worst case, happens more often than you might think ...\\

[[https://en.wikipedia.org/wiki/Miguel_de_Icaza][Miguel De Icaza]] is one the fathers' of the [[https://en.wikipedia.org/wiki/The_GNOME_Project][GNOME Project]], one of the best
[[https://en.wikipedia.org/wiki/Desktop_environment][desktop environments]] for Linux. For a few years in the late 90s and early 00s,
it looked like Linux desktop distributions based on GNOME had a real shot with
competing with Microsoft Windows to become a popular desktop operating system.
However despite all the excitement, huge community effort, and commercial
support from major Linux vendors, it never really happened. Miguel explains why
in his blog post [[https://tirania.org/blog/archive/2012/Aug-29.html][What Killed the Linux Desktop]] (worth a read).

#+BEGIN_QUOTE 
Backwards compatibility is not a sexy problem. It is not even remotely an
interesting problem to solve. Nobody wants to do that work, everyone wants to
innovate, and be responsible for the next big feature in Linux.

So Linux was left with idealists that wanted to design the best possible system
without having to worry about boring details like support and backwards
compatibility.

Meanwhile, you can still run the 2001 Photoshop that came when XP was launched
on Windows 8. And you can still run your old OSX apps on Mountain Lion...
-- [[https://en.wikipedia.org/wiki/Miguel_de_Icaza][Miguel De Icaza]], 2012
#+END_QUOTE

It's a sobering message, ABI stability done right helped contribute to Linux's
vast success as an operating system and done wrong, it hurt it's popularity as
desktop operating system. The risk is for project's with an unstable ABI is
clear, eventually your consumers will start looking for something else that
doesn't break their code quite so much.

DPDK's has had an [[https://doc.dpdk.org/guides-19.08/contributing/versioning.html][ABI policy]] committing the community to preserving the DPDK ABI
since 2015.

#+BEGIN_QUOTE
Note that the above process for ABI deprecation should not be undertaken
lightly. ABI stability is extremely important for downstream consumers of the
DPDK, especially when distributed in shared object form. Every effort should be
made to preserve the ABI whenever possible. The ABI should only be changed for
significant reasons, such as performance enhancements. ABI breakage due to
changes such as reorganizing public structure fields for aesthetic or
readability purposes should be avoided. 
-- DPDK ABI Policy, 19.08
#+END_QUOTE

The DPDK ABI policy encourages contributors to be mindful of consumers when
making ABI changes. What is changing in DPDK, is that this policy is now
evolving to offer consumers more guarantees of future compatibility.

** How we are changing DPDK?

Recently the 6th revision of a new ABI [[http://inbox.dpdk.org/dev/1569603283-1857-1-git-send-email-mdr@ashroe.eu/][policy]] was posted to the community,
intended to start the process of moving DPDK out of the last category of
projects described above and providing it's consumers with more certainty around
future ABI compatibility. This policy has been approved in principle by the [[http://inbox.dpdk.org/dev/20190927140255.GA1865@bricha3-MOBL.ger.corp.intel.com/][DPDK
Technical Board]] and will become the new policy following the DPDK 19.11 LTS
release.

The intention is to continue to provide DPDK's consumers the best possible
features and performance for building dataplane applications, now with the
addition of clearer upgrade paths and a stronger commitment to backward
compatibility.

The change will mean that DPDK will now follow a pattern similar to that
described for the LibAV and FFMpeg projects above. A pattern that is
characterized by periods of ABI stability with periodic ABI breakages to
facilitate change. In this way, a DPDK "major" ABI version will be declared
aligned with the DPDK LTS release, and then supported in all the quarterly
release over the year following the LTS release.

** What does this mean for Contributors?

At a high-level, it means that the community will become more deliberate about
how the DPDK ABI is managed. Any new features will be required to maintain
existing interfaces between LTS releases, and in general ABI changes will
receive more scrutiny than has been the case in the past.\\

To be absolutely clear, the DPDK ABI _*can*_ change while ABI compatibility is
being maintained.\\

This means that the DPDK community will guarantee, that applications built and
dynamically linked against the most recent LTS release will continue to work,
without requiring a rebuild, through the quarterly releases for the year
following the LTS release. The DPDK ABI can and will continue to evolve during
this period, adding great new features and improvements, so long as ABI
compatibility with the LTS release is preserved.

Changes that are so dramatic as to require an ABI compatibility breakage will
now need to wait until the next ABI breakage window at the next LTS release.

** How do we prepare for this change?

The initial period of ABI stability will run for one year following the v19.11
release. This was designed to minimize disruption to the community, as most
contributors are targeting the LTS release with their changes. Currently ABI
breakage windows are aligned with LTS releases, meaning that even in the worst
case event of an unavoidable ABI breaking change, the impact of the new policy
will be minimal.

This has been designed to start to familiarize the community with the
requirements of ABI compatibility, while still permitting ABI breakages for the
next LTS release. The ABI policy will then be reviewed after this initial year,
with the intention of lengthening the stability period and period between ABI
breakages to two years.

If you are interested in the next level of detail of how the new policy will
work, can review the [[http://inbox.dpdk.org/dev/1569603283-1857-1-git-send-email-mdr@ashroe.eu/][patch]].\\

Ray Kinsella & Thomas Monjalon
